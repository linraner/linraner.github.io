---
title: 数论初步
date: 2017-12-31 18:57:58
tags: 
- acm 
- 数论
---

数论被“数学王子”高斯誉为整个数学王国的皇后

## 欧几里得算法

### 最大公约数

欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g

#### 代码示例
<!-- more -->
```
//递归
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
//迭代
int gcd(int a, int b) {
    while(b != 0) {
        int r = b;
        b = a % b;
        a = r;
    }
    return a;
}
```

### 唯一分解定理

### 扩展欧几里得算法

[题目]()

直线上的点。求直线``ax+by+c=0``上有多少整数点(x,y)满足x<-[x1, x2], y <- [y1, y2]
定理：若a和b为正整数，则存在整数x,y使得``gcd(a,b)=ax+by``

#### 代码示例

```cpp
void gcd(int a, int b, int& d, int& x, int& y) {
    if (!b) {
        d = a;
        x = 1;
        y = 0;
    } else {
        gcd(b, a % b, d, y, x);
        y -= x * (a / b);
    }
}
```

### 素数筛选

[题目](http://acm.hdu.edu.cn/diy/contest_showproblem.php?pid=1001&cid=32790)

#### 代码示例

```cpp
//一般判定是否是素数
bool is_prime(int n) {
	if (n < 2)
		return false;
	for (int i = 2; i <= sqrt(n); i++) {
		if (n % i == 0)
			return false;
	}
	return true;
}
//普通筛选n内的素数
bool* com_prime(int n) {
	bool* ans = new bool[n];
	for (int i = 0; i < n; i++) 
		ans[i] = false;
	for (int i = 2; i < n; i++) {
		if (is_prime(i))
			ans[i] = true;
	}
	return ans;
}
```

#### 筛选法示例

一、初始化如下列表。

 2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

二、把第一个数（2）取出来，去掉所有可以被2整除的数。

 2  3     5     7     9    11    13    15    17    19    21    23    25    27    29

三、取第二个数（3），去掉所有可以被 3整除的数。

 2  3     5     7          11    13          17    19          23    25          29

四、取第三个数（5），因为4已经被去除了，再去掉所有可以被5整除的数。

 2  3     5     7          11    13          17    19          23                29

接下来的数是7，但是7的平方是49，其大于了30，所以我们可以停止计算了。剩下的数就是所有的质数了。

```cpp
#include <iostream>
#include <cmath>
#define MAX 1000
using namespace std;
bool is_prime(int n) {
	if (n < 2)
		return false;
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0)
			return false;
	}
	return true;
}
bool* sieve_prime(int n) {
	bool* value = new bool[n];
	for (int i = 0; i < n; i++)
		value[i] = true;
	value[0] = false;
	value[1] = false;
	
	for (int i = 2; i <= sqrt(n); i++) {
		if (value[i] && is_prime(i)) {
			int c = 2;
			int j = i * c;
			while (j < n) {
				value[j] = false;
				j = i * c++;
			}
		}
	}
	return value;
}
int main() {
    bool* prime = sieve_prime(MAX);
    for (int i = 1; i <=100; i++) { //输出100内的素数
        if (prime[i])
            cout << i << endl;
    }
}
```

## 欧拉函数

**欧拉函数：** 在数论中，对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目。它又称为Euler's totient function、φ函数、欧拉商数等。
例如 φ，因为1,3,5,7均和8互质。------ 维基百科
### 定理
* phi(1) = 1
* n为质数, phi(n) = n - 1
* m 和 n 互质, phi(mn) = phi(m) * phi(n)
* n为奇数, phi(2n) = phi(n)
* 通用公式：``phi(n) = n * (1 - 1 / p1) * (1 - 1 / p2) * ... * (1 - 1 / pr)``
其中 ``n = p1^k1 * p2^k2 * ... * pr^kr``
* **具体参考：** [看云-欧拉函数](https://www.kancloud.cn/kancloud/rsa_algorithm/48486)

#### 常规代码
```
int phi(int n) {
    int t = n;
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            n /= i;
            t = t - t / i;
        }
        while (n % i == 0)
            n /= i;
    }
    return t;
}
```
时间复杂度O(n),对于1e9会超时。

#### 改良之后
```
int phi(int n) {
    int t = n;
    //降低时间复杂度
    for (int  i = 2; i * i <= n; i++) {
        if (n % i == 0) {
        n /= i;
        t = t - t / i;
        }
        while (n % i == 0) 
            n /= i;
    }
    if (n > 1)
    t = t - t / n;
    return t;
}
```
