---
title: 位运算笔记
date: 2018-08-01 18:16:21
tags: 
- notes
- algorithm
---

## 位运算
### & 、|、 ^
```java
a & a = a
a | a = a
a ^ a = 0
a & 0 = 0
a | 0 = a
a ^ 0 = a
a | ( a & b ) = a
a & ( a | b ) = a
```
### a、b值交换
```java
a ^= b;
b ^= a;
a ^= b;
```
### 判断奇偶（取最后一位）
```java
a & 1 <==> a % 2
```
### i+1位置为1
```java
// 1110 => 1111
a |= 1 << i
```
### i+1位置为0
```
// 1111 => 1101
a &= ~(1 << i)
```
### 取出i+1位
```java
// i = 2, 7 => 4
a = a & (1 << i)
```
### 删除最后的1
```java
// 1100 => 1000
a = a & (a-1)
```
### 在对应i+1位，插入b的对应位
```
a |= 1 << i; （a的bit位置1）
a & (b & 1<<i) （与b的bit位相与）
```
### 得到最高位的1
```java
a = a |(a>>1);
a = a |(a>>2);
a = a |(a>>4);
a = a |(a>>8);
a = a |(a>>16);
return (a+1)>>1;
```
### 检测一个无符号整数是否是2^n -1的形式
```java
x&(x+1)
```
### 移位
在`Java`中正数`>>`等价于`>>>`，负数在内存中已补码形式保存，`>>>`表示无符号右移。
### “1”位计数

统计一个字（比如32bit）中，有多少个bit是1，有多少个bit是0。

这里以32bit为例来说明算法，这里基本思想类似折半计算。算法复杂度O(lgn)
```java
x = (x & 0x55555555) + ((x>>1)& 0x55555555);
x = (x & 0x33333333) + ((x>>2)& 0x33333333);
x = (x & 0x0F0F0F0F) + ((x>>4)& 0x0F0F0F0F);
x = (x & 0x00FF00FF) + ((x>>8)& 0x00FF00FF);
x = (x & 0x0000FFFF) + ((x>>16)& 0x0000FFFF);
```
### 搜索
---待续

## 参考
1. [《Hacker's Delight》](https://book.douban.com/subject/1784887/)





