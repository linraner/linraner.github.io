---
title: 快速幂
date: 2017-10-31 18:57:58
tags: 
- acm
- 数论
---


### 快速幂
![](http://oxqn1kqf7.bkt.clouddn.com/17-10-31/1725298.jpg)

通常算法：
```
int Pow(int A, int n)
{
    if(n == 0) 
        return 1;
    int rslt(1);
    for(int i(0); i < n; ++i)
        rslt *= A;
    return rslt;
}
```
<!-- more -->
其复杂度是O(n)的。一般来说，这样的复杂度并不会使我们困惑，但是一般应用幂运算的地方，指数都会非常非常的大，比如1 000 000 000这个级别的，这时候我们会遇到两个问题，第一个就是我们不能再用int来存储整数，必须用高精度整数类型来进行存储，另一个就是在指数是如此变态的数量级之下，我们的计算量会骤然上升，结果也会异常惊人的大。简单来说就是二分法。
举个栗子：
一般解法：
`A^8 = A * A * A * A * A * A * A * A`
总共需要7次乘法运算

平均分解：
`A^8 = (A * A * A * A) * (A * A * A * A) = (A * A * A * A) ^ 2`
这样我们就只需要4次乘法运算

再分解：
`A^6 = [(A * A) * (A * A)] ^ 2 = [(A * A) ^ 2] ^ 2`
这样就将乘法运算的次数减少为了3次

这种二分解法可以将原本n次的运算减少为logn / log2，这样的效果是惊人的，在1 000 000 000这样数量级的指数运算下，该方法可以将运算次数减少到30次

整数的快速幂：
```
int qPow(int A, int n)
{
    if(n == 0) 
        return 1;
    int rslt(1);

    while(n)
    {
        if(n & 1) // 若幂为奇数
        {
            rslt *= A;
        }
        A *= A;
        n >>= 1; // 右位移等价于除以2
    }
    return rslt;
}
```
矩阵类的代码：
```
class Matrix
{
public:
    int N; // 矩阵维数
    int** m; // 存储矩阵的二维数组

    Matrix(int n = 2)
    {
        m = new int*[n];
        for(int i(0); i < n; ++i)
        {
            m[i] = new int[n];
        }
        N = n;
        clear();
    }

    // 将矩阵清空为零矩阵
    void clear()
    {
        for(int i(0); i < N; ++i)
        {
            memset(m[i], 0, sizeof(int) * N);
        }
    }

    // 将矩阵设定为单位矩阵
    void unit()
    {
        clear();
        for(int i(0); i < N; ++i)
        {
            m[i][i] = 1;
        }
    }

    // 矩阵的赋值
    Matrix operator= (Matrix &othr)
    {
        Matrix(othr.N);
        for(int i(0); i < othr.N; ++i)
        {
            for(int j(0); j < othr.N; ++j)
            {
                m[i][j] = othr.m[i][j];
            }
        }
        return *this;
    }

    // 矩阵的乘法
    //!假设所有因子均为同阶方阵
    Matrix operator* (Matrix &othr)
    {
        Matrix rslt(othr.N);
        for(int i(0); i < othr.N; ++i)
        {
            for(int j(0); j < othr.N; ++j)
            {
                for(int k(0); k < othr.N; ++k)
                {
                    rslt.m[i][j] += m[i][k] * othr.m[k][j];
                }
            }
        }
        return rslt;
    }
};
```
矩阵快速幂的算法:
```
Matrix qMPow(Matrix &A, int n)
{
    Matrix rslt(A.N);
    rslt.unit();
    if(n == 0) return rslt;
    while(n)
    {
        if(n & 1) // 若幂为奇数
        {
            rslt = rslt * A;
        }
        A = A * A;
        n >>= 1; // 右位移等价于除以2
    }
    return rslt;
}
```