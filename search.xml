<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式复习]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[设计模式复习23种设计模式主要分为三类：创建型模式、结构型模式、行为型模式。 创建型模式单例模式 实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 代码实现 饿汉式 线程安全 1234567class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 懒汉式 双向检查锁定 12345678910111213141516class Singleton &#123; // volatile 多线程安全, 但屏蔽Java虚拟机优化, 效率降低 private volatile static Singleton instance = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; // 锁定代码块 synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 使用静态内部类实现 12345678910// IoDH 初始化不会失败使用, 延迟加载public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125; private Singleton() &#123;&#125;&#125; 使用枚举类型 123public enum Singleton&#123; INSTANCE;&#125; 枚举类反编译之后会被转换成形如public final class T extends Enum的定义。枚举中的各个枚举项通过static来定义。 一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全），所以枚举类是线程安全的。 结构型模式代理模式 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问，必须经过代理才能访问被代理对象。在应用场景上不同于装饰者模式，更偏向于代理的含义，代理模式重点在于控制对象的行为，而装饰模式侧重于增加对象的职能，为对象增加额外的职能。 结构如下： Java中实现动态代理Java中代理模式有动态代理、静态代理、Cglib代理。 Java中实现动态代理的步骤：1.定义一个委托类和公共接口。 2.自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类 3.生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。 4.Java 实现动态代理主要涉及以下几个类： java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy。 java.lang.reflect.InvocationHandler: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。 例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 接口 */interface Subject &#123; void request();&#125;public class DynamicProxyDemo01 &#123; public static void main(String[] args) &#123; RealSubject realSubject = new RealSubject();//1.创建委托对象 ProxyHandler handler = new ProxyHandler(realSubject);//2.创建调用处理器对象 //3.动态生成代理对象 Subject proxySubject = (Subject) Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); proxySubject.request(); //4.通过代理对象调用方法 &#125;&#125;/** * 委托类 */class RealSubject implements Subject &#123; public void request() &#123; System.out.println("Real Subject Request"); &#125;&#125;/** * 代理类的调用处理器 */class ProxyHandler implements InvocationHandler &#123; private Subject subject; public ProxyHandler(Subject subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作 System.out.println("====before===="); Object result = method.invoke(subject, args); System.out.println("====after===="); return result; &#125;&#125; 行为型模式观察者模式 观察者模式优点： 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。 观察者模式缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。 策略模式 策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式采用了面向对象的继承和多态机制。 策略模式适合使用在：1.多个类只有在算法或行为上稍有不同的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。 使用策略模式当然也有需要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过4个，则需要考虑混合模式，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过工厂方法模式来实现策略类的声明。 优点：1.算法可以自由切换。2.避免使用多重条件判断。3.扩展性良好。 参考 为什么我墙裂建议大家使用枚举来实现单例。 代理模式及Java实现动态代理]]></content>
      <tags>
        <tag>interview</tag>
        <tag>notes</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问卷星自动提交脚本]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%97%AE%E5%8D%B7%E6%98%9F%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[python实现对问卷星问卷的批量答题.思路 分析页面结构, 问题标号: q+第几题, 问题选项: q+第几题+_第几个选项. 对一次提交进行抓包, 抓取post数据包.对submidata进行解码得到如下.明显看出是题号$选项号}组成的. 写python脚本构造post请求. 12345678910111213141516171819202122import requestsfrom time import *from random import randintfor i in range(10): header = &#123; 'Host': 'www.wjx.cn', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0', 'X-Forwarded-For': str(randint(1, 255)) + '.' + str(randint(1, 255)) + '.' + str(randint(1, 255)) + '.' + str( randint(1, 255)), 'Referer': 'https://www.wjx.cn###.aspx', 'Cookie': 'acw_tc=2f624a1f154##', &#125; print("第 " + str(i) + " 提交" + " Using IP:" + header['X-Forwarded-For'] + ' to compalte this Q.') data = "submitdata=1$%s&#125;2$%s&#125;3$%s&#125;4$%s&#125;5$%s&#125;6$%s&#125;7$%s&#125;8$3&#125;9$-3&#125;10$-3&#125;11$%s&#125;12$%s&#125;13$%s&#125;14$%s&#125;15$%s&#125;16$%s&#125;17$%s&#125;18$%s" % ( str(randint(1, 7)), str(randint(1, 9)), str(randint(1, 4)), str(randint(1, 3)), str(randint(1, 4)), str(randint(1, 3)), str(randint(1, 3)), str(randint(1, 2)), str(randint(1, 2)), str(randint(1, 4)), str(randint(1, 2)), str(randint(1, 2)), str(randint(1, 3)), str(randint(1, 2)), str(randint(1, 3))) url = 'https://www.wjx.cn/joinnew/processjq.ashx?curid=34131883&amp;starttime=2019%2F1%2F25%2021%3A37%3A12&amp;source=directphone&amp;submittype=1&amp;ktimes=213&amp;hlv=1&amp;rn=1034449004.44465961&amp;t=1548423507485&amp;jqnonce=c5825f6b-67d7-40c8-ba2e-e1ffb82c4642&amp;jqsign=%606%3B16e5a.54g4.73%60%3B.ab1f.f2eea%3B1%607571' r = requests.post(url, data=data, headers=header) # print(r)print("Complate.")]]></content>
      <tags>
        <tag>skill</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除提交到github上的账号密码]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%B8%85%E9%99%A4%E6%8F%90%E4%BA%A4%E5%88%B0github%E4%B8%8A%E7%9A%84%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、删库。。。。 二、使用BFG Repo-Cleaner地址： BFG Repo-Cleaner 简单使用12345#克隆副本git clone --mirror git://example.com/example.git#清理分支java -jar bfg-1.13.0.jar --replace-text pwd.txt example.gitcd example.git &amp; git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive &amp; git push git 取消对某个文件的track.gitignore无法对已经track的文件忽略123git rm --cached example.filesgit commitgit push]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Stream]]></title>
    <url>%2F2018%2F10%2F15%2FJava8%20Stream%2F</url>
    <content type="text"><![CDATA[代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class Java8Stream &#123; public static void main(String args[]) &#123; System.out.println("使用 Java 7: "); // 计算空字符串 List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abcd", "", "jkl"); System.out.println("列表: " + strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println("空字符数量为: " + count); count = getCountLength3UsingJava7(strings); System.out.println("字符串长度为 3 的数量为: " + count); // 删除空字符串 List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println("筛选后的列表: " + filtered); // 删除空字符串，并使用逗号把它们合并起来 String mergedString = getMergedStringUsingJava7(strings, ", "); System.out.println("合并字符串: " + mergedString); List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取列表元素平方数 List&lt;Integer&gt; squaresList = getSquares(numbers); System.out.println("平方数列表: " + squaresList); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19); System.out.println("列表: " + integers); System.out.println("列表中最大的数 : " + getMax(integers)); System.out.println("列表中最小的数 : " + getMin(integers)); System.out.println("所有数之和 : " + getSum(integers)); System.out.println("平均数 : " + getAverage(integers)); System.out.println("随机数: "); // 输出10个随机数 Random random = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(random.nextInt()); &#125; System.out.println("使用 Java 8: "); System.out.println("列表: " + strings); count = strings.stream().filter(string -&gt; string.isEmpty()).count(); System.out.println("空字符串数量为: " + count); count = strings.stream().filter(string -&gt; string.length() == 3).count(); System.out.println("字符串长度为 3 的数量为: " + count); filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println("筛选后的列表: " + filtered); mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", ")); System.out.println("合并字符串: " + mergedString); squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList()); System.out.println("Squares List: " + squaresList); System.out.println("列表: " + integers); IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println("列表中最大的数 : " + stats.getMax()); System.out.println("列表中最小的数 : " + stats.getMin()); System.out.println("所有数之和 : " + stats.getSum()); System.out.println("平均数 : " + stats.getAverage()); System.out.println("随机数: "); random.ints().limit(10).sorted().forEach(System.out::println); // 并行处理 count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); System.out.println("空字符串的数量为: " + count); &#125; private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) &#123; int count = 0; for (String string : strings) &#123; if (string.isEmpty()) &#123; count++; &#125; &#125; return count; &#125; private static int getCountLength3UsingJava7(List&lt;String&gt; strings) &#123; int count = 0; for (String string : strings) &#123; if (string.length() == 3) &#123; count++; &#125; &#125; return count; &#125; private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) &#123; List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;(); for (String string : strings) &#123; if (!string.isEmpty()) &#123; filteredList.add(string); &#125; &#125; return filteredList; &#125; private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) &#123; StringBuilder stringBuilder = new StringBuilder(); for (String string : strings) &#123; if (!string.isEmpty()) &#123; stringBuilder.append(string); stringBuilder.append(separator); &#125; &#125; String mergedString = stringBuilder.toString(); return mergedString.substring(0, mergedString.length() - 2); &#125; private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) &#123; List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;(); for (Integer number : numbers) &#123; Integer square = new Integer(number.intValue() * number.intValue()); if (!squaresList.contains(square)) &#123; squaresList.add(square); &#125; &#125; return squaresList; &#125; private static int getMax(List&lt;Integer&gt; numbers) &#123; int max = numbers.get(0); for (int i = 1; i &lt; numbers.size(); i++) &#123; Integer number = numbers.get(i); if (number.intValue() &gt; max) &#123; max = number.intValue(); &#125; &#125; return max; &#125; private static int getMin(List&lt;Integer&gt; numbers) &#123; int min = numbers.get(0); for (int i = 1; i &lt; numbers.size(); i++) &#123; Integer number = numbers.get(i); if (number.intValue() &lt; min) &#123; min = number.intValue(); &#125; &#125; return min; &#125; private static int getSum(List numbers) &#123; int sum = (int) (numbers.get(0)); for (int i = 1; i &lt; numbers.size(); i++) &#123; sum += (int) numbers.get(i); &#125; return sum; &#125; private static int getAverage(List&lt;Integer&gt; numbers) &#123; return getSum(numbers) / numbers.size(); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Date AND Time API]]></title>
    <url>%2F2018%2F10%2F05%2FJava8%20Date%20Time%20API%2F</url>
    <content type="text"><![CDATA[Java8 引入了新的时间类使用 LocalDate 和 LocalTime创建 LocalDate 对象并读取值1234567891011121314151617//2013-03-06LocalDate date = LocalDate.of(2012,03,06);//2012int year = date.getYear();//MARCHMonth month = date.getMonth();//TUESDAYDayOfWeek dow = date.getDayOfWeek();//6int day = date.getDayOfMonth();//31int len = date.lengthOfMonth();//falseboolean leap = date.isLeapYear();//使用工厂方法获取系统日期LocalDate today = LocalDate.now();LocalTime time = LocalTime.now().withNano(0);//去除毫秒 TemporalField 是一个接口, 定义了如何访问 temporal 对象某个字段的值. ChronoField 枚举实现这一接口. 123int year = date.get(ChronoField.YEAR);int month = date.get(ChronoField.MONTH_OF_YEAR);int day = date.get(ChronoField.DAY_OF_MONTH); LocalDate 和 LocalTime 都可以解析字符串创建. 12LocalDate date = LocalDate.parse("2012-12-22");LocalTime time = LocalTime.parse("22:22:22"); 操作、解析和格式化使用 TemporalAdjuster]]></content>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 九大内置对象常用方法]]></title>
    <url>%2F2018%2F10%2F01%2FJSP%20%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. request 对象常用方法request 是来自客户端的请求. 客户端的请求信息封装在 request 对象中. 以下 HttpServletRequest 类的实例. 方法 ( 类型 + 方法名 ) 描述 String getParameter(String strTextName) 获取表单提交信息 Enumeration getParameterNames() 返回可用参数的枚举 String[] getParameterValues(String name) 返回包含参数 name 的所有的数组 Enumeration getAttributeNames() 返回所有属性名的属性值 Object getAttribute(String name) 返回指定属性的属性值 String getCharacterEncoding() 返回字节编码方式 String getProtocol() 获取用户使用的协议 String getServletPath() 获取用户提交信息的页面 String getMethod() 获取客户提交信息的方式 BufferReader getHeader() 获取 HTTP 头文件的 accept、accept-encoding 和 Host 的值 String getRemoteAddr() 获取客户的 IP 地址 String getRemoteHost() 获取客户机的名称 String getserverName() 获取服务器的名称 int getServerPort() 获取服务器端口号 2. resopnse 对象常用方法resopnse 对象代表的是对客户端的相应. 向客户端发送文字时直接使用. 以下是 HttpServletResopnse 类的实例. 方法 ( 类型 + 方法名 ) 描述 String getCharacterEncoding() 返回响应用的是什么字符编码 ServletOutputStream getOutputStream() 返回响应的一个二进制输出流 PrintWrite getWrite() 返回可以向客户端输出字符的一个对象 void setContentLength(int len) 设置响应头长度 void setContentTye(String type) 设置响应的 MIME 类型 void sendRedirect(Java.lang.String location) 重新定向客户端的请求 3. session 常用方法session 指的是客户端与服务器的一次回话, 从客户连接到服务器的一个 WebApplication 开始, 直到客户端与服务器断开连接为止. 它是 HttpSession 类的实例. 方法 ( 类型 + 方法名 ) 描述 long getCreationTime() 创建 session 创建时间 public String getId() 返回 session 创建时JSP引擎为它设置的唯一ID号 long getLastAccessedTime() 返回 session 里客户端最近一次请求时间 int getMaxInactiveInterval() 返回两次请求间隔多长时间此 session 被取消 String[] getValueNames() 返回一个包含此 session 中所有可用属性的数组 void invalidate() 取消 session , 使 session 不可用 boolean isNew() 返回服务器创建爱你的一个 session , 客户端是否已经加入 void removeValue(String name) 删除 session 中指定的属性 void setMaxInactiveInterval() session 被取消 (ms) 4. out 常用方法out 对象是 JspWriter 类的实例, 是向客户端输出内容常用的对象. 方法 ( 类型 + 方法名 ) 描述 void clear() 清除缓冲区的内容 void clearBuffer() 清除缓冲区的当前内容 void flush() 清空流 int getBufferSize() 返回缓冲区以字节数的大小,如果不设置为0 int getRemaining() 返回缓冲区还有多少剩余可用 bool isAutoFlush() 返回缓冲区满时,是自动清空还是抛出异常 void close() 关闭输出流 5. page 常用方法page 指当前 JSP 页面本身, 有点像类中的 this 指针, 它是 java.langlObject 类的实例. 「page」对象代表正在运行的由 jsp 文件产生的类对象. 方法 ( 类型 + 方法名 ) 描述 class getClass() 返回此 Object 的类 int hashCode() 返回此 Object 的 hash 码 boolean equals(Object obj) 判断此 Object 是否与指定的 Object 对象相等 void copy(Object obj) 把此 Object 拷贝到指定的 Object 对象中 Object clone() 克隆此 Object 对象 String toString() 把此 Object 对象转换成 String 类的对象 void notify() 唤醒一个等待的进程 void notifyAll() 唤醒所有等待的进程 void wait(int timeout) 使一个进程处于等待直到 timeout 结束或者被唤醒 void wait() 使一个线程处于等待直到被唤醒 void enterMonitor() 对 Object 进行加锁 void exitMonitor() 对 Object 进行开锁 6. application 常用方法application 实现了用户间数据的共享, 可存放全局变量. 它开始于服务器的启动, 直到服务器的关闭, 在此期间, 此对象将一直存在; 这样在用户的前后连接或者不同用户之间的连接中, 可以对此对象的同一属性进行操作; 在任何地方对此对象属性的操作, 都将影响到其他对象对此的访问. 服务器的启动和关闭决定了 application 对象的生命. 它是 ServletContest类的实例.]]></content>
      <tags>
        <tag>JSP</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda表达式]]></title>
    <url>%2F2018%2F09%2F28%2Flambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[lambda表达式是一行函数，是函数式编程的一种特性。 pythonlambda &lt;参数&gt;: 表达式123&gt;&gt;&gt; f = lambda a,b: a + b&gt;&gt;&gt; type(f)#&lt;type 'function'&gt; 获取整除2的数字12&gt;&gt;&gt; list(filter(lambda x: x%2==0, range(10)))#[0, 2, 4, 6, 8] 列表并行排序1234&gt;&gt;&gt; list1 = [1,2,3,2,3];list2 = [9,4,3,5,6]&gt;&gt;&gt; data = zip(list1, list2)&gt;&gt;&gt; data = sorted(data)&gt;&gt;&gt; list1, list2 = map(lambda t: list(t), zip(*data)) cpp c++里的形式是这样的[capture list] (parameter list) -&gt;return type {function body} 示例123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; //call the func. auto f1 = []() &#123; cout &lt;&lt; "test" &lt;&lt; endl; &#125;; f1(); int y = 2; auto f2 = [y](int x) &#123; cout &lt;&lt; x + y &lt;&lt; endl; &#125;; f2(4); //STL vector&lt;int&gt; v; for (int i = 0; i &lt; 10; ++i) &#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), [](int n) &#123; if (n % 2 == 0) &#123; cout &lt;&lt; n &lt;&lt; " "; &#125; &#125;); return 0;&#125;]]></content>
      <tags>
        <tag>python</tag>
        <tag>函数式编程</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django重置后台密码]]></title>
    <url>%2F2018%2F09%2F28%2FDjango%E9%87%8D%E7%BD%AE%E5%90%8E%E5%8F%B0%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[emmm时间长忘记密码了 执行1$ python manage.py shell 修改12345In [1]: from django.contrib.auth.models import UserIn [2]: user = User.objects.get(username='Username')In [3]: user.set_password('Password')In [4]: user.save()In [5]: exit()]]></content>
      <tags>
        <tag>skill</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++的字符串与数字的转换]]></title>
    <url>%2F2018%2F09%2F28%2Fc%2B%2B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数字转字符串1234567#include &lt;sstream&gt;double a = 123.456;string s;stringstream ss;ss &lt;&lt; a;ss &gt;&gt; s;ss.clear(); 12345#include &lt;map&gt;map&lt;int, char&gt; m;for (int i = 0; i &lt; 10; i++) &#123; m[i] = i + '0';&#125; 1234#include &lt;cstdio&gt;char str[10];double a = 123.456;sprintf(str, "%.3lf", a); 123char str[10];int a=175;sprintf(str,"%x",a);//10进制转换成16进制，如果输出大写的字母是sprintf(str,"%X",a) 字符串转数字 1234567#include &lt;sstream&gt;string s = "123.456";double a;stringstream ss;ss &lt;&lt; s;ss &gt;&gt; a;ss.clear(); 12345#include &lt;map&gt;map&lt;char, int&gt; m;for (int i = 0; i &lt; 10; i++) &#123; m[i+'0'] = i;&#125; 1234#include &lt;cstdio&gt;char str[] = "123.456";double a;sscanf(str, "%lf", &amp;a); 123char str[]="AF";int a;sscanf(str,"%x",&amp;a); //16进制转换成10进制 123456#include &lt;cstdlib&gt;int a;float b;long c;a=atoi("32");b=atof("3.1415");c=atol("567283");printf ("%d\n%f\n%d\n",a,b,c);]]></content>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20行代码的签到脚本(Python)]]></title>
    <url>%2F2018%2F07%2F28%2F20%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[懒得每天在某个网站签到，写了一个python脚本扔在云主机上。网站很简单，代码就几十行。 签到脚本12345678910111213141516171819import requestsusername = "####"password = "####"loginUrl = "登录路径/auth/login"s = requests.Session()logindata = &#123; 'email':username, 'passwd':password, 'remember_me':'ture',&#125;r = s.post(loginUrl,data=logindata)r = s.get(loginUrl)checkinUrl="签到的路径/user/checkin"rr = s.post(checkinUrl)#执行签到rr = s.get(loginUrl)# print(rr)# print(rr._content.decode())exit() 在Linux上定时执行这个脚本 1crontab -e 进入编辑模式，设置每天8:00运行一次。crontab的语法规范分钟 小时 日期 月份 周 命令 100 8 * * * python /opt/checkin.py]]></content>
      <tags>
        <tag>python</tag>
        <tag>skill</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django链接MySQL问题]]></title>
    <url>%2F2018%2F06%2F21%2Fdjango%E9%93%BE%E6%8E%A5mysql%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[错误1（django.db.utils.OperationalError: (1045, &quot;Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)&quot;)） 环境： Django2.0 MySQL8.0.11 Mysql 8.0 的部分语法，密码的加密方式发生了改变，在8.0 中的用户密码采用的是cha2 加密方法, 从而密码认证错误。 解决:123$ mysql -u root -pmysql&gt; use mysql;mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;;]]></content>
      <tags>
        <tag>skill</tag>
        <tag>django</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nothing added to commit but untracked files present解决方法]]></title>
    <url>%2F2018%2F05%2F30%2Fnothing-added-to-commit-but-untracked-files-present%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题描述123456789101112$ git commit On branch master Initial commit Untracked files: .gitignore Test/ blogpost/ manage.py nothing added to commit but untracked files present 文件被追踪，但是没有被添加git中 解决 git status 列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件 1234$ git add manage.py$ git add blogpost\$ git add Test\$ git add .gitignore]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++枚举next_premutation]]></title>
    <url>%2F2018%2F05%2F28%2Fc%2B%2B%E6%9E%9A%E4%B8%BEnext_premutation%2F</url>
    <content type="text"><![CDATA[平均复杂度即为O(n) next_permutation() 会改变区间[begin,end)内的元素次序，使它们符合“下一个排列次序”； prev_permutation() 会改变区间[begin,end)内的元素次序，使它们符合“上一个排列次序”； 示例 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void f(vector&lt;int&gt; v)&#123; for(int i=0;i&lt;v.size();i++)&#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;int main() &#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(3); v.push_back(2); cout&lt;&lt;"原排列 ： "; f(v); for(int i=0;i&lt;10;i++)&#123; next_permutation(v.begin(),v.end());//升序序列 或者下一个排列次序 按照字典序生成下一个序列 f(v); &#125; //for(int i=0;i&lt;5;i++)&#123; // prev_permutation(v.begin(),v.end());//降序 // f(v); //&#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu错误-Could not get lock /var/lib/dpkg/lock]]></title>
    <url>%2F2018%2F05%2F15%2FUbuntu%E9%94%99%E8%AF%AF-Could-not-get-lock-var-lib-dpkg-lock%2F</url>
    <content type="text"><![CDATA[报错信息12E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解决办法 查看运行的线程123ps -A | grep apt-get# sudo kill processnumber# 关闭apt进程 我的没有发现进程， 可能是上次运行安装或更新时没有正常完成造成的 终端输入12sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock]]></content>
      <tags>
        <tag>skill</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ std::ios_base::sync_with_stdio 加速输入输出]]></title>
    <url>%2F2018%2F05%2F14%2Fc-std-ios-base-sync-with-stdio-%E5%8A%A0%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[static bool sync_with_stdio( bool sync = true );设置标准 C++ 流是否与标准 C 流在每次输入/输出操作后同步。 遇到cin TLE时可以用于取消cin同步, 取消之后不能和 scanf，sscanf, getchar, fgets 之类同用。 测试 123456789#include &lt;iostream&gt;#include &lt;cstdio&gt; int main() &#123; std::ios::sync_with_stdio(false); std::cout &lt;&lt; "a\n"; std::printf("b\n"); std::cout &lt;&lt; "c\n";&#125; 输出 （环境 g++5.4.0）123bca 默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。 12std::ios::sync_with_stdio(false);std::cin.tie(0); 参考一 ： http://zh.cppreference.com/w/cpp/io/ios_base/sync_with_stdio 参考二 ：http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html]]></content>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 WIFI 热点问题]]></title>
    <url>%2F2018%2F05%2F08%2FWindow-WIFI-%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[win10玄学bug之一 解决方案 ： 命令行输入12$ netsh wlan set hostednetwork mode=allow ssid=NAME key=PASSWORD$ netsh wlan start hostednetwork 然后在网络适配器的本地连接-&gt;属性-&gt;共享-&gt;设置共享刚才设置的WIFI热点]]></content>
      <tags>
        <tag>windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python解决字符编码问题]]></title>
    <url>%2F2018%2F05%2F05%2FPython%E8%A7%A3%E5%86%B3%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[字符串分为unicode 和 str 两种类型 文本字符和二进制数据分别用 str 和 byte表示 12345#系统默认编码设置为utf-8&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefultencoding'utf-8'&gt;&gt;&gt; str 与 bytes 之间的转换可以用 encode 和从decode 1234567&gt;&gt;&gt; s = "Python测试"&gt;&gt;&gt; s = s.encode()&gt;&gt;&gt; print(s)b'Python\xe6\xb5\x8b\xe8\xaf\x95'&gt;&gt;&gt; s = s.decode()&gt;&gt;&gt; print(s)'Python测试' base64123456&gt;&gt;&gt; import base64&gt;&gt;&gt; s = "asdasd"&gt;&gt;&gt; s = base64.b64encode(s)&gt;&gt;&gt; print(s)&gt;&gt;&gt; s = base64.b64decode(s)&gt;&gt;&gt; print(s) 参考 ： https://foofish.net/how-python3-handle-charset-encoding.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS]]></title>
    <url>%2F2018%2F04%2F01%2FBFS%2F</url>
    <content type="text"><![CDATA[入门迷宫问题（最短路径）INPUT:1234565 5SXXXX...XX.X.....XXX....G 123456786 6.......S..X.XXX.......X..X..XX.GX... OUPUT:12810 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int INF = 100000007;const int mx = 1007;typedef pair&lt;int, int&gt; P;char maze[mx][mx];//地图int n, m;int sx, sy;//开始坐标 int gx, gy;//结束坐标 int d[mx][mx];//到各个位置的最短距离数组 int dx[4] = &#123;1,0,-1,0&#125;, dy[4] = &#123;0,1,0,-1&#125;;//移动向量 //（sx,sy)----&gt;(gx,gy)最短路径//无法到达就是 INF int bfs()&#123; queue&lt;P&gt; que; //初始化所有位置为INF for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; d[i][j]=INF; &#125; &#125; //放入起点 que.push(P(sx,sy)); d[sx][sy]=0; //队列不为空一直执行 while(que.size())&#123; //取出队列前端元素 P p=que.front(); que.pop(); //取出为终点结束搜索 if(p.first==gx&amp;&amp;p.second==gy) break; //4个方向的移动 for(int i=0;i&lt;4;i++)&#123; //移动之后的位置 int nx=p.first+dx[i], ny=p.second+dy[i]; //判断是否访问过 if(0&lt;=nx&amp;&amp;nx&lt;n&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;m&amp;&amp;d[nx][ny]==INF&amp;&amp;maze[nx][ny]!='X')&#123; que.push(P(nx,ny));//放入队列， 并到该位置的距离+1 d[nx][ny]=d[p.first][p.second]+1; &#125; &#125; &#125; return d[gx][gy];&#125;void solve()&#123; int ans=bfs(); cout &lt;&lt; ans;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; scanf("%s",maze[i]); for(int j=0;j&lt;m;j++)&#123; if(maze[i][j]=='S')&#123; sx=i;sy=j; &#125; if(maze[i][j]=='G')&#123; gx=i;gy=j; &#125; &#125; &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目 : L2-010. 排座位布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。 输入格式：输入第一行给出3个正整数：N（&lt;= 100），即前来参宴的宾客总人数，则这些人从1到N编号；M为已知两两宾客之间的关系数；K为查询的条数。随后M行，每行给出一对宾客之间的关系，格式为：“宾客1 宾客2 关系”，其中“关系”为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后K行，每行给出一对需要查询的宾客编号。 这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。 输出格式：对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出“No problem”；如果他们之间并不是朋友，但也不敌对，则输出“OK”；如果他们之间有敌对，然而也有共同的朋友，则输出“OK but…”；如果他们之间只有敌对关系，则输出“No way”。 输入样例：123456789101112137 8 45 6 12 7 -11 3 13 4 16 7 -11 2 11 4 12 3 -13 45 72 37 2 输出样例：1234No problemOKOK but...No way 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*11 8 61 21 32 45 65 76 87 910 114 63 95 911 67 83 4*/#include &lt;iostream&gt;using namespace std;int pre[100007];//节点 int enemy[1007][1007];int find(int x) &#123;//查找源头标号 int r = x; while (pre[r] != r) r = pre[r]; int i = x, j; while (i != r)//路径压缩算法 &#123; j = pre[i];//在改变他的前导点时，存储他的值 pre[i] = r; i = j;//改变他的前导点为根节点 /* 1---&gt;2---&gt;3 1---&gt;3 / / / 2 */ &#125; return r;&#125;void Union(int a, int b) &#123;//合并 a=find(a); b=find(b); if(a==b) return; if (a!=b) pre[a]=b; &#125; int main() &#123; int n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; //初始每个元素为一个根节点 for(int i=1;i&lt;=n;i++)&#123; pre[i]=i; &#125; int a,b,c; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(c==1)&#123; Union(a,b); &#125;else&#123; enemy[a][b]=1; enemy[b][a]=1; &#125; &#125; for(int i=0;i&lt;p;i++)&#123; cin&gt;&gt;a&gt;&gt;b; if(find(a)==find(b)&amp;&amp;enemy[a][b]==0)&#123; cout&lt;&lt;"No problem"&lt;&lt;endl; &#125;else if(find(a)!=find(b)&amp;&amp;enemy[a][b]==0)&#123; cout&lt;&lt;"OK"&lt;&lt;endl; &#125;else if(find(a)==find(b)&amp;&amp;enemy[a][b]==1)&#123; cout&lt;&lt;"OK but..."&lt;&lt;endl; &#125;else if(enemy[a][b]==1)&#123; cout&lt;&lt;"No way"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS]]></title>
    <url>%2F2018%2F04%2F01%2FDFS%2F</url>
    <content type="text"><![CDATA[入门求连通块INPUT :1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0 OUTPUT :12340122 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int mx = 10007;int n, m;char field[mx][mx];//地图 void dfs(int x, int y)&#123; field[x][y] = '*';//替换现在位置 //遍历8个方向 for(int dx=-1;dx&lt;=1;dx++)&#123; for(int dy=-1;dy&lt;=1;dy++)&#123; int nx=x+dx, ny=y+dy; if(0&lt;=nx&amp;&amp;nx&lt;n&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;m&amp;&amp;field[nx][ny]=='@') dfs(nx,ny); &#125; &#125; return ;&#125; void solve()&#123; int ans=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; //从@处开始遍历 if(field[i][j]=='@')&#123; dfs(i,j); ans++; &#125; &#125; &#125; cout&lt;&lt;ans;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; scanf("%s",field[i]); &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论初步]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[数论被“数学王子”高斯誉为整个数学王国的皇后 欧几里得算法最大公约数欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g 代码示例 12345678910111213//递归int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;//迭代int gcd(int a, int b) &#123; while(b != 0) &#123; int r = b; b = a % b; a = r; &#125; return a;&#125; 唯一分解定理扩展欧几里得算法题目 直线上的点。求直线ax+by+c=0上有多少整数点(x,y)满足x&lt;-[x1, x2], y &lt;- [y1, y2]定理：若a和b为正整数，则存在整数x,y使得gcd(a,b)=ax+by 代码示例12345678910void gcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) &#123; if (!b) &#123; d = a; x = 1; y = 0; &#125; else &#123; gcd(b, a % b, d, y, x); y -= x * (a / b); &#125;&#125; 素数筛选题目 代码示例123456789101112131415161718192021//一般判定是否是素数bool is_prime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;//普通筛选n内的素数bool* com_prime(int n) &#123; bool* ans = new bool[n]; for (int i = 0; i &lt; n; i++) ans[i] = false; for (int i = 2; i &lt; n; i++) &#123; if (is_prime(i)) ans[i] = true; &#125; return ans;&#125; 筛选法示例一、初始化如下列表。 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 二、把第一个数（2）取出来，去掉所有可以被2整除的数。 2 3 5 7 9 11 13 15 17 19 21 23 25 27 29 三、取第二个数（3），去掉所有可以被 3整除的数。 2 3 5 7 11 13 17 19 23 25 29 四、取第三个数（5），因为4已经被去除了，再去掉所有可以被5整除的数。 2 3 5 7 11 13 17 19 23 29 接下来的数是7，但是7的平方是49，其大于了30，所以我们可以停止计算了。剩下的数就是所有的质数了。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cmath&gt;#define MAX 1000using namespace std;bool is_prime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;bool* sieve_prime(int n) &#123; bool* value = new bool[n]; for (int i = 0; i &lt; n; i++) value[i] = true; value[0] = false; value[1] = false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; if (value[i] &amp;&amp; is_prime(i)) &#123; int c = 2; int j = i * c; while (j &lt; n) &#123; value[j] = false; j = i * c++; &#125; &#125; &#125; return value;&#125;int main() &#123; bool* prime = sieve_prime(MAX); for (int i = 1; i &lt;=100; i++) &#123; //输出100内的素数 if (prime[i]) cout &lt;&lt; i &lt;&lt; endl; &#125;&#125; 欧拉函数欧拉函数： 在数论中，对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目。它又称为Euler’s totient function、φ函数、欧拉商数等。例如 φ，因为1,3,5,7均和8互质。—— 维基百科 定理 phi(1) = 1 n为质数, phi(n) = n - 1 m 和 n 互质, phi(mn) = phi(m) * phi(n) n为奇数, phi(2n) = phi(n) 通用公式：phi(n) = n * (1 - 1 / p1) * (1 - 1 / p2) * ... * (1 - 1 / pr)其中 n = p1^k1 * p2^k2 * ... * pr^kr 具体参考： 看云-欧拉函数 常规代码123456789101112int phi(int n) &#123; int t = n; for (int i = 2; i &lt;= n; i++) &#123; if (n % i == 0) &#123; n /= i; t = t - t / i; &#125; while (n % i == 0) n /= i; &#125; return t;&#125; 时间复杂度O(n),对于1e9会超时。 改良之后123456789101112131415int phi(int n) &#123; int t = n; //降低时间复杂度 for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; n /= i; t = t - t / i; &#125; while (n % i == 0) n /= i; &#125; if (n &gt; 1) t = t - t / n; return t;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scanf中的正则表达式]]></title>
    <url>%2F2017%2F12%2F01%2Fscanf%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[调用格式: scanf(&quot;&lt;格式化字符串&gt;&quot;, &lt;地址表&gt;);一、为变量赋值时表示成功读取变量的个数, &lt;格式化字符串&gt;与&lt;地址表&gt;是严格匹配的 12scanf("%c %c", &amp;a, &amp;b); //函数返回值是2，并丢弃不想使用的空白符scanf("%d,%d", &amp;a, &amp;b); //输入必须有逗号， 多个空格为一个空格 二、 %s 读取遇到空格停止读取，因此一般可以用fgets去读取字符串123scanf("%[a-z]", &amp;str); //遇到不再a-z字符停止读取scanf("666%[0-9]", &amp;str); //666开头并且在0-9字符读取，不是则停止scanf("%[^\n]", &amp;str); //^表示求反集，即这句话不是回车一直开始读取 三、压缩输入：在格式码前加上*，则用户就可以告诉scanf()读这个域，但不把它赋予任何变量。 1scanf("%c%*c, &amp;ch); 使用此方法可以在字符处理时吃掉多余的回车。 更多正则表达式语言参考 sscanf、scanf的一些示例12]]></content>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git问题：Everything up-to-date解决]]></title>
    <url>%2F2017%2F11%2F04%2FGit%E9%97%AE%E9%A2%98%EF%BC%9AEverything-up-to-date%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[push代码时遇到提示：Everything up-to-date,无法push代码原因是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。我们应该告诉git提交哪个分支。 解决在stackoverflow有解决方案 创建分支123$ git branch newbranch#查看分支$ git branch 切换分支1$ git checkout newbranch 改动提交到新的分支12$ git add .$ git commit -a 合并到master123$ git merge newbranch#查看冲突$ git diff push代码1$ git push -u origin master 删除分支1$ git branch -D newbranch 删除合并部分大写D改为小写d]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂 通常算法：123456789int Pow(int A, int n)&#123; if(n == 0) return 1; int rslt(1); for(int i(0); i &lt; n; ++i) rslt *= A; return rslt;&#125; 其复杂度是O(n)的。一般来说，这样的复杂度并不会使我们困惑，但是一般应用幂运算的地方，指数都会非常非常的大，比如1 000 000 000这个级别的，这时候我们会遇到两个问题，第一个就是我们不能再用int来存储整数，必须用高精度整数类型来进行存储，另一个就是在指数是如此变态的数量级之下，我们的计算量会骤然上升，结果也会异常惊人的大。简单来说就是二分法。举个栗子：一般解法：A^8 = A * A * A * A * A * A * A * A总共需要7次乘法运算 平均分解：A^8 = (A * A * A * A) * (A * A * A * A) = (A * A * A * A) ^ 2这样我们就只需要4次乘法运算 再分解：A^6 = [(A * A) * (A * A)] ^ 2 = [(A * A) ^ 2] ^ 2这样就将乘法运算的次数减少为了3次 这种二分解法可以将原本n次的运算减少为logn / log2，这样的效果是惊人的，在1 000 000 000这样数量级的指数运算下，该方法可以将运算次数减少到30次 整数的快速幂：1234567891011121314151617int qPow(int A, int n)&#123; if(n == 0) return 1; int rslt(1); while(n) &#123; if(n &amp; 1) // 若幂为奇数 &#123; rslt *= A; &#125; A *= A; n &gt;&gt;= 1; // 右位移等价于除以2 &#125; return rslt;&#125; 矩阵类的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Matrix&#123;public: int N; // 矩阵维数 int** m; // 存储矩阵的二维数组 Matrix(int n = 2) &#123; m = new int*[n]; for(int i(0); i &lt; n; ++i) &#123; m[i] = new int[n]; &#125; N = n; clear(); &#125; // 将矩阵清空为零矩阵 void clear() &#123; for(int i(0); i &lt; N; ++i) &#123; memset(m[i], 0, sizeof(int) * N); &#125; &#125; // 将矩阵设定为单位矩阵 void unit() &#123; clear(); for(int i(0); i &lt; N; ++i) &#123; m[i][i] = 1; &#125; &#125; // 矩阵的赋值 Matrix operator= (Matrix &amp;othr) &#123; Matrix(othr.N); for(int i(0); i &lt; othr.N; ++i) &#123; for(int j(0); j &lt; othr.N; ++j) &#123; m[i][j] = othr.m[i][j]; &#125; &#125; return *this; &#125; // 矩阵的乘法 //!假设所有因子均为同阶方阵 Matrix operator* (Matrix &amp;othr) &#123; Matrix rslt(othr.N); for(int i(0); i &lt; othr.N; ++i) &#123; for(int j(0); j &lt; othr.N; ++j) &#123; for(int k(0); k &lt; othr.N; ++k) &#123; rslt.m[i][j] += m[i][k] * othr.m[k][j]; &#125; &#125; &#125; return rslt; &#125;&#125;; 矩阵快速幂的算法:12345678910111213141516Matrix qMPow(Matrix &amp;A, int n)&#123; Matrix rslt(A.N); rslt.unit(); if(n == 0) return rslt; while(n) &#123; if(n &amp; 1) // 若幂为奇数 &#123; rslt = rslt * A; &#125; A = A * A; n &gt;&gt;= 1; // 右位移等价于除以2 &#125; return rslt;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda常用操作(windows)]]></title>
    <url>%2F2017%2F10%2F28%2Fconda%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[管理conda验证安装1$ conda --version 命令参阅可以用: conda –help 将conda更新到最新123$ conda update conda#有最新选择yesProceed ([y]/n)? y 管理环境创建环境123$ conda create --name snowflakes biopython#也可以指定python版本并安装Astroid和Babel$ conda create --name snowflakes python3.5 astroid babel 使用biopython创建一个snowflakes的环境 不指定目录即为默认目录/envs 使用环境123$ activate newen#切换回根目录$ deactivate 显示安装过的环境1$ conda info --envs 括号显示为当前环境 切换到另一个环境1$ activate another_environment 克隆删除环境1234#克隆$ conda create --name flowers --clone snowflakes#删除$ conda remove --name flowers --all 管理Python检查可安装的python版本123$ conda search --full-name python#列出包含python的所有包$ conda search python 安装python3环境并不覆盖python21$ conda create --name snackes pyhton=3 包管理看安装的包和版本列表1$ conda list 查找、安装、删除123$ conda search beautifulsoup4$ conda install --name snowflakes beautifulsoup4 #未指定位置安装在当前位置$ conda remove --name snowflakes beautifulsoup4 从Anaconda.org安装包1$ conda install --channel https://conda.anaconda.org/pandas bottleneck 更多命令具体参考：Getting started]]></content>
      <tags>
        <tag>skill</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学使用Git]]></title>
    <url>%2F2017%2F10%2F24%2F%E5%88%9D%E5%AD%A6%E4%BD%BF%E7%94%A8Git%2F</url>
    <content type="text"><![CDATA[Git使用规范流程Git是一个源码管理系统我采取ThoughtBot的Git使用规范流程 第一步：新建分支每次开发新功能，都应该新建一个单独的分支。123456#获取主干最新代码$ git checkout master$ git pull#新建开发分支$ git checkout -b afeature 第二步：提交分支commit 分支修改后，提交commit123456#all为保存所有变化(包括新建、修改和删除)$ git add --all#查看发生变动的文件。$ git status#verbose会列出diff的结果$ git commit --verbose diff是Unix系统的一个很重要的工具程序，具体见：读懂diff - 阮一峰的网络日志 第三步：撰写提交信息提交commit时，必须给出完整扼要的提交信息。以下是一个范本：1234Persent-tense summary under 50 characters*More information about commit(under 72 characters)*More information about commit(under 72 characters)http://project.management-system.com/ticket/123 第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、需要注意的问题。最后，提供对应的网址。 第四步：与主干同步12$ git fetch orgin$ git rebase orgin/master 第五步：合并commit分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个(或最多两三个) commit，这样不仅清晰，也容易管理。1$ git rebase -i origin/master 具体参考：Git 使用规范流程 第六步：推送到远程仓库合并commit，推送当前分支到远程仓库。1$ git push --force origin myfeature 第七步：发出Pull Request提交到远程仓库以后，就可以发出Pull Request 到master 分支，然后请求别人进行代码review，确认可以合并到master。 Git常用操作]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通向外网的梯子]]></title>
    <url>%2F2017%2F10%2F22%2F%E9%80%9A%E5%90%91%E5%A4%96%E7%BD%91%E7%9A%84%E6%A2%AF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[机场最为方便 v2ray适合自建 …]]></content>
      <tags>
        <tag>tools</tag>
        <tag>gfw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter NoteBook常用快捷键]]></title>
    <url>%2F2017%2F10%2F21%2FJupyter-NoteBook%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Jupyter Notebook 有两种键盘输入模式，命令模式和编辑模式。与Vim类似。 命令模式按Esc进入，编辑模式按Enter进入 命令模式快捷键 快捷键 作用 Shift+Enter 运行本单元，选中下一个单元 Ctrl+Enter 运行本单元 Alt+Enter 运行本单元在下插入新单元 Y 单元转入代码状态 M 单元转入markdown状态 R 单元转入raw状态 Up&amp;K/Down&amp;J 选中上方/下方单元 Shift+K/J 连续选择上方/下方单元 A/B 在上方/下方插入新单元 x/C 剪切/复制选中单元 Shift+V/V 粘贴到上方/下方单元 Z 恢复删除的最后一个单元 DD 删除选中的单元 Shift+M 合并选中的单元 Ctrl+S/S 保存当前文件 L 开关行号 O 转换输出 Shift+O 转换输出滚动 Esc/Q 关闭页面 H 显示快捷帮助 II/00 中断/重启NOteBook内核 Shift+Space/Space 向上/下滚动 编辑模式快捷键 快捷键 作用 Tab 代码补全或者缩进 Shift+Tab 提示 Ctrl+] 向右缩进 Ctrl+[ 向左缩进 Ctrl+Shift+Z/Ctrl+Y 重做 Ctrl+up/down 跳到单元开头/末尾 Ctrl+Left/Right 跳到左边/右边一个字首 Ctrl+BackSpace/Delete 删除前面一个字 Shift+Enter 运行本单元，选中下一个单元 Ctrl+M 切换到命令模式 Ctrl+Enter 运行本单元 Alt+Enter 运行本单元在下插入新单元 Ctrl+/ 注释整行或者取消注释]]></content>
      <tags>
        <tag>skill</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows上好用的软件]]></title>
    <url>%2F2017%2F10%2F14%2FWindows%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[WoxWox：是开源免费强大的快捷启动器辅助工具，快速高效率打开软件,搜索文件打开输入框：alt + space 同类软件也有: Listary , Rolan 包管理工具Chocolatey：如果你认为没有包管理的操作系统是反人类的就用这个吧，Chocolatey 这套包管理系统目前已经包含了近 500 多款常用软件，常用的有Sublime text,git,Google Chrome······ 命令行工具 MobaXterm, 功能强大cmder： 不多说，windows命令行神器，支持tab补全，支持了大部分的Linux命令······ 文本编辑器Sublime text3：基于 Python 语言的外挂 API,跨平台（Windows、Linux 和 Mac OS X）,兼容 TextMate 的语言标记语法。关于软件的配置方面见：这里sublime text 3 3143 license 12345678910111213—– BEGIN LICENSE —–TwitterInc200 User LicenseEA7E-8900071D77F72E 390CDD93 4DCBA022 FAF6079061AA12C0 A37081C5 D0316412 4584D13694D7F7D4 95BC8C1C 527DA828 560BB037D1EDDD8C AE7B379F 50C9D69D B35179EF2FE898C4 8E4277A8 555CE714 E1FB0E43D5D52613 C3D12E98 BC49967F 7652EED29D2D2E61 67610860 6D338B72 5CF95C69E36B85CC 84991F19 7575D828 470A92AB—— END LICENSE —— 同类也有： VS Code：毕竟宇宙级的 Atom：Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置Git版本控制系统。(维基百科)，插件需要科学上网 Notepad++：Notepad++，由台湾人侯今吾基于同是开放源代码的Scintilla文本编辑组件并独力研发，整个项目托管于SourceForge.net之上，并两度获得SourceForge社区选择奖——最佳开发工具。（维基百科） 由于sublime现在有些功能没有， 我现在使用的是VScode IDE没什么说的，大多数网上都能下载，JetBrains家的东西都不错，由于对学生免费，即用教育网邮箱注册，就能获得大学在校的使用时间，分享一个用于接收EDU邮箱的网站：点击这里 待续—– 注：0x13哒的缘故，上面网址有的需要突破GFW的封锁，科学上网详见：这里]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
