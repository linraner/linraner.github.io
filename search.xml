<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017第八届蓝桥杯C/C++ B组省赛题解]]></title>
    <url>%2F2018%2F01%2F22%2F2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFC-C-B%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[第一题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273标题： 购物单 小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。 这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。 小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。 现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。 取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。 你的任务是计算出，小明最少需要取多少现金。以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。-----------------**** 180.90 88折**** 10.25 65折**** 56.14 9折**** 104.65 9折**** 100.30 88折**** 297.15 半价**** 26.75 65折**** 130.62 半价**** 240.28 58折**** 270.62 8折**** 115.87 88折**** 247.34 95折**** 73.21 9折**** 101.00 半价**** 79.54 半价**** 278.44 7折**** 199.26 半价**** 12.97 9折**** 166.30 78折**** 125.50 58折**** 84.98 9折**** 113.35 68折**** 166.57 半价**** 42.56 9折**** 81.90 95折**** 131.78 8折**** 255.89 78折**** 109.17 9折**** 146.69 68折**** 139.33 65折**** 141.16 78折**** 154.74 8折**** 59.42 8折**** 85.44 68折**** 293.70 88折**** 261.79 65折**** 11.30 88折**** 268.27 58折**** 128.29 88折**** 251.03 8折**** 208.39 75折**** 128.88 75折**** 62.06 9折**** 225.87 75折**** 12.89 75折**** 34.28 75折**** 62.16 58折**** 129.12 半价**** 218.37 半价**** 289.69 8折--------------------需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。特别地，半价是按50%计算。请提交小明要从取款机上提取的金额，单位是元。答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。特别提醒：不许携带计算器入场，也不能打开手机。 善用记事本的查找替换23333333333 答案 ： 5200 12345678910111213//OUTPUT : 5136.86#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; freopen("1.txt","r",stdin); double sum = 0, a, b; while(scanf(" %lf %lf", &amp;a, &amp;b) == 2) &#123; sum = sum + a * b / 100; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125; 第二题1234567891011121314标题：等差素数列2,3,5,7,11,13,....是素数序列。类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。上边的数列公差为30，长度为6。2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。这是数论领域一项惊人的成果！有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：长度为10的等差素数列，其公差最小值是多少？注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。 素数打表后寻找等差数列 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#define MAX 1000007bool is_prime(int a) &#123; if (a &lt; 2) return false; for (int i = 2; i * i &lt;= a; i++) &#123; if (a % i == 0) return false; &#125; return true;&#125;int prime[MAX], k = 0;int main() &#123; for (int i = 1; i &lt; MAX; i++) &#123; if (is_prime(i)) prime[k++] = i; &#125; //cout &lt;&lt; k &lt;&lt; endl;//prime num for (int i = 0; i &lt; 1007; i++) &#123;//尝试在1000内筛选 int a1 = prime[i], cnt, flag = 0, temp = 0; for (int d = 1; d &lt; 666; d++) &#123; cnt = 1; while (is_prime(a1 + cnt * d)) &#123; cnt++; if (cnt == 10) &#123; flag = 1; temp = d; break; &#125; &#125; &#125; if (flag == 1) cout &lt;&lt; temp &lt;&lt; endl; &#125;&#125; 第三题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950标题：承压计算X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。每块金属原料的外形、尺寸完全一致，但重量不同。金属材料被严格地堆放成金字塔形。 7 5 8 7 8 8 9 2 7 2 8 1 4 9 1 8 1 8 8 4 1 7 9 6 1 4 5 4 5 6 5 5 6 9 5 6 5 5 4 7 9 3 5 5 1 7 5 7 9 7 4 7 3 3 1 4 6 4 5 5 8 8 3 2 4 3 1 1 3 3 1 6 6 5 5 4 4 2 9 9 9 2 1 9 1 9 2 9 5 7 9 4 3 3 7 7 9 3 6 1 3 8 8 3 7 3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 其中的数字代表金属块的重量（计量单位较大）。最下一层的X代表30台极高精度的电子秤。假设每块原料的重量都十分精确地平均落在下方的两个金属块上，最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。电子秤的计量单位很小，所以显示的数字很大。工作人员发现，其中读数最小的电子秤的示数为：2086458231请你推算出：读数最大的电子秤的示数为多少？注意：需要提交的是一个整数，不要填写任何多余的内容。 答案 ： 72665192664 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;double a[31][31] = &#123;0&#125;;int main() &#123; double max = -1e10, min = 1e10; freopen("3.txt", "r", stdin); for (int i = 0; i &lt; 29; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for (int i = 1; i &lt;= 29; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (j == 0) &#123; a[i][j] += a[i-1][0]/2.0; &#125; else &#123; a[i][j] += a[i-1][j-1]/2.0 + a[i-1][j]/2.0; &#125; &#125; &#125; for (int i = 0; i &lt;= 29; i++) &#123; if (a[29][i] &lt; min) min = a[29][i]; if (a[29][i] &gt; max) max = a[29][i]; &#125; //大数输出用printf,cout省略一部分 printf("%lf\n", 2086458231/min*max);&#125; 第四题123456789101112标题：方格分割6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如图：p1.png, p2.png, p3.png 就是可行的分割法。试计算：包括这3种分法在内，一共有多少种不同的分割方法。注意：旋转对称的属于同一种分割法。请提交该整数，不要填写任何多余的内容或说明文字。 12 第五题123456789101112131415161718192021222324252627282930标题：取数位求1个整数的第k位数字有很多种方法。以下的方法就是一种。// 求x用10进制表示时的数位长度 int len(int x)&#123; if(x&lt;10) return 1; return len(x/10)+1;&#125; // 取x的第k位数字int f(int x, int k)&#123; if(len(x)-k==0) return x%10; return _____________________; //填空&#125; int main()&#123; int x = 23574; printf(&quot;%d\n&quot;, f(x,3)); return 0;&#125;对于题目中的测试数据，应该打印5。请仔细分析源码，并补充划线部分所缺少的代码。注意：只提交缺失的代码，不要填写任何已有内容或说明性的文字。 答案 ： f(x/10,k) 第六题12345678910111213141516171819202122232425262728293031323334353637383940414243444546标题：最大公共子串最大公共子串长度问题就是：求两个串的所有子串中能够匹配上的最大长度是多少。比如：&quot;abcdkkk&quot; 和 &quot;baabcdadabc&quot;，可以找到的最长的公共子串是&quot;abcd&quot;,所以最大公共子串长度为4。下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。请分析该解法的思路，并补全划线部分缺失的代码。#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 256int f(const char* s1, const char* s2)&#123; int a[N][N]; int len1 = strlen(s1); int len2 = strlen(s2); int i,j; memset(a,0,sizeof(int)*N*N); int max = 0; for(i=1; i&lt;=len1; i++)&#123; for(j=1; j&lt;=len2; j++)&#123; if(s1[i-1]==s2[j-1]) &#123; a[i][j] = __________________________; //填空 if(a[i][j] &gt; max) max = a[i][j]; &#125; &#125; &#125; return max;&#125;int main()&#123; printf(&quot;%d\n&quot;, f(&quot;abcdkkk&quot;, &quot;baabcdadabc&quot;)); return 0;&#125;注意：只提交缺少的代码，不要提交已有的代码和符号。也不要提交说明性文字。 第七题1234567891011121314151617181920212223242526272829303132333435363738394041标题：日期问题小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。 比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。 给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？输入----一个日期，格式是&quot;AA/BB/CC&quot;。 (0 &lt;= A, B, C &lt;= 9) 输入----输出若干个不相同的日期，每个日期一行，格式是&quot;yyyy-MM-dd&quot;。多个日期按从早到晚排列。 样例输入----02/03/04 样例输出----2002-03-04 2004-02-03 2004-03-02 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。注意：main函数需要返回0;只使用ANSI C/ANSI C++ 标准;不要调用依赖于编译环境或操作系统的特殊函数。所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;不能通过工程设置而省略常用头文件。提交程序时，注意选择所期望的语言类型和编译器类型。 第八题第九题第十题]]></content>
      <tags>
        <tag>蓝桥杯  算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论初步]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[数论被“数学王子”高斯誉为整个数学王国的皇后 欧几里得算法最大公约数欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g 代码示例12345678910111213//递归int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;//迭代int gcd(int a, int b) &#123; while(b != 0) &#123; int r = b; b = a % b; a = r; &#125; return a;&#125; 唯一分解定理扩展欧几里得算法题目 直线上的点。求直线ax+by+c=0上有多少整数点(x,y)满足x&lt;-[x1, x2], y &lt;- [y1, y2]定理：若a和b为正整数，则存在整数x,y使得gcd(a,b)=ax+by 代码示例12345678910void gcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) &#123; if (!b) &#123; d = a; x = 1; y = 0; &#125; else &#123; gcd(b, a % b, d, y, x); y -= x * (a / b); &#125;&#125; 素数筛选题目 代码示例123456789101112131415161718192021//一般判定是否是素数bool is_prime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;//普通筛选n内的素数bool* com_prime(int n) &#123; bool* ans = new bool[n]; for (int i = 0; i &lt; n; i++) ans[i] = false; for (int i = 2; i &lt; n; i++) &#123; if (is_prime(i)) ans[i] = true; &#125; return ans;&#125; 筛选法示例一、初始化如下列表。 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 二、把第一个数（2）取出来，去掉所有可以被2整除的数。 2 3 5 7 9 11 13 15 17 19 21 23 25 27 29 三、取第二个数（3），去掉所有可以被 3整除的数。 2 3 5 7 11 13 17 19 23 25 29 四、取第三个数（5），因为4已经被去除了，再去掉所有可以被5整除的数。 2 3 5 7 11 13 17 19 23 29 接下来的数是7，但是7的平方是49，其大于了30，所以我们可以停止计算了。剩下的数就是所有的质数了。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cmath&gt;#define MAX 1000using namespace std;bool is_prime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;bool* sieve_prime(int n) &#123; bool* value = new bool[n]; for (int i = 0; i &lt; n; i++) value[i] = true; value[0] = false; value[1] = false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; if (value[i] &amp;&amp; is_prime(i)) &#123; int c = 2; int j = i * c; while (j &lt; n) &#123; value[j] = false; j = i * c++; &#125; &#125; &#125; return value;&#125;int main() &#123; bool* prime = sieve_prime(MAX); for (int i = 1; i &lt;=100; i++) &#123; //输出100内的素数 if (prime[i]) cout &lt;&lt; i &lt;&lt; endl; &#125;&#125; 欧拉函数欧拉函数： 在数论中，对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目。它又称为Euler’s totient function、φ函数、欧拉商数等。例如 φ，因为1,3,5,7均和8互质。—— 维基百科 定理 phi(1) = 1 n为质数, phi(n) = n - 1 m 和 n 互质, phi(mn) = phi(m) * phi(n) n为奇数, phi(2n) = phi(n) 通用公式：phi(n) = n * (1 - 1 / p1) * (1 - 1 / p2) * ... * (1 - 1 / pr)其中 n = p1^k1 * p2^k2 * ... * pr^kr 具体参考： 看云-欧拉函数 常规代码123456789101112int phi(int n) &#123; int t = n; for (int i = 2; i &lt;= n; i++) &#123; if (n % i == 0) &#123; n /= i; t = t - t / i; &#125; while (n % i == 0) n /= i; &#125; return t;&#125; 时间复杂度O(n),对于1e9会超时。 改良之后123456789101112131415int phi(int n) &#123; int t = n; //降低时间复杂度 for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; n /= i; t = t - t / i; &#125; while (n % i == 0) n /= i; &#125; if (n &gt; 1) t = t - t / n; return t;&#125;]]></content>
      <tags>
        <tag>acm 数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scanf中的正则表达式]]></title>
    <url>%2F2017%2F12%2F01%2Fscanf%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[调用格式: scanf(&quot;&lt;格式化字符串&gt;&quot;, &lt;地址表&gt;);一、为变量赋值时表示成功读取变量的个数, &lt;格式化字符串&gt;与&lt;地址表&gt;是严格匹配的 12scanf("%c %c", &amp;a, &amp;b); //函数返回值是2，并丢弃不想使用的空白符scanf("%d,%d", &amp;a, &amp;b); //输入必须有逗号， 多个空格为一个空格 二、 %s 读取遇到空格停止读取，因此一般可以用fgets去读取字符串 123scanf("%[a-z]", &amp;str); //遇到不再a-z字符停止读取scanf("666%[0-9]", &amp;str); //666开头并且在0-9字符读取，不是则停止scanf("%[^\n]", &amp;str); //^表示求反集，即这句话不是回车一直开始读取 三、压缩输入：在格式码前加上*，则用户就可以告诉scanf()读这个域，但不把它赋予任何变量。 1scanf("%c%*c, &amp;ch); 使用此方法可以在字符处理时吃掉多余的回车。 更多正则表达式语言参考 sscanf、scanf的一些示例12]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git问题：Everything up-to-date解决]]></title>
    <url>%2F2017%2F11%2F04%2FGit%E9%97%AE%E9%A2%98%EF%BC%9AEverything-up-to-date%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[push代码时遇到提示：Everything up-to-date,无法push代码原因是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。我们应该告诉git提交哪个分支。 解决在stackoverflow有解决方案 创建分支123$ git branch newbranch#查看分支$ git branch 切换分支1$ git checkout newbranch 改动提交到新的分支12$ git add .$ git commit -a 合并到master123$ git merge newbranch#查看冲突$ git diff push代码1$ git push -u origin master 删除分支1$ git branch -D newbranch 删除合并部分大写D改为小写d]]></content>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂 通常算法：123456789int Pow(int A, int n)&#123; if(n == 0) return 1; int rslt(1); for(int i(0); i &lt; n; ++i) rslt *= A; return rslt;&#125; 其复杂度是O(n)的。一般来说，这样的复杂度并不会使我们困惑，但是一般应用幂运算的地方，指数都会非常非常的大，比如1 000 000 000这个级别的，这时候我们会遇到两个问题，第一个就是我们不能再用int来存储整数，必须用高精度整数类型来进行存储，另一个就是在指数是如此变态的数量级之下，我们的计算量会骤然上升，结果也会异常惊人的大。简单来说就是二分法。举个栗子：一般解法：A^8 = A * A * A * A * A * A * A * A总共需要7次乘法运算 平均分解：A^8 = (A * A * A * A) * (A * A * A * A) = (A * A * A * A) ^ 2这样我们就只需要4次乘法运算 再分解：A^6 = [(A * A) * (A * A)] ^ 2 = [(A * A) ^ 2] ^ 2这样就将乘法运算的次数减少为了3次 这种二分解法可以将原本n次的运算减少为logn / log2，这样的效果是惊人的，在1 000 000 000这样数量级的指数运算下，该方法可以将运算次数减少到30次 整数的快速幂：1234567891011121314151617int qPow(int A, int n)&#123; if(n == 0) return 1; int rslt(1); while(n) &#123; if(n &amp; 1) // 若幂为奇数 &#123; rslt *= A; &#125; A *= A; n &gt;&gt;= 1; // 右位移等价于除以2 &#125; return rslt;&#125; 矩阵类的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Matrix&#123;public: int N; // 矩阵维数 int** m; // 存储矩阵的二维数组 Matrix(int n = 2) &#123; m = new int*[n]; for(int i(0); i &lt; n; ++i) &#123; m[i] = new int[n]; &#125; N = n; clear(); &#125; // 将矩阵清空为零矩阵 void clear() &#123; for(int i(0); i &lt; N; ++i) &#123; memset(m[i], 0, sizeof(int) * N); &#125; &#125; // 将矩阵设定为单位矩阵 void unit() &#123; clear(); for(int i(0); i &lt; N; ++i) &#123; m[i][i] = 1; &#125; &#125; // 矩阵的赋值 Matrix operator= (Matrix &amp;othr) &#123; Matrix(othr.N); for(int i(0); i &lt; othr.N; ++i) &#123; for(int j(0); j &lt; othr.N; ++j) &#123; m[i][j] = othr.m[i][j]; &#125; &#125; return *this; &#125; // 矩阵的乘法 //!假设所有因子均为同阶方阵 Matrix operator* (Matrix &amp;othr) &#123; Matrix rslt(othr.N); for(int i(0); i &lt; othr.N; ++i) &#123; for(int j(0); j &lt; othr.N; ++j) &#123; for(int k(0); k &lt; othr.N; ++k) &#123; rslt.m[i][j] += m[i][k] * othr.m[k][j]; &#125; &#125; &#125; return rslt; &#125;&#125;; 矩阵快速幂的算法:12345678910111213141516Matrix qMPow(Matrix &amp;A, int n)&#123; Matrix rslt(A.N); rslt.unit(); if(n == 0) return rslt; while(n) &#123; if(n &amp; 1) // 若幂为奇数 &#123; rslt = rslt * A; &#125; A = A * A; n &gt;&gt;= 1; // 右位移等价于除以2 &#125; return rslt;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda常用操作(windows)]]></title>
    <url>%2F2017%2F10%2F28%2Fconda%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[管理conda验证安装1$ conda --version 命令参阅可以用: conda –help 将conda更新到最新123$ conda update conda#有最新选择yesProceed ([y]/n)? y 管理环境创建环境123$ conda create --name snowflakes biopython#也可以指定python版本并安装Astroid和Babel$ conda create --name snowflakes python3.5 astroid babel 使用biopython创建一个snowflakes的环境 不指定目录即为默认目录/envs 使用环境123$ activate newen#切换回根目录$ deactivate 显示安装过的环境1$ conda info --envs 括号显示为当前环境 切换到另一个环境1$ activate another_environment 克隆删除环境1234#克隆$ conda create --name flowers --clone snowflakes#删除$ conda remove --name flowers --all 管理Python检查可安装的python版本123$ conda search --full-name python#列出包含python的所有包$ conda search python 安装python3环境并不覆盖python21$ conda create --name snackes pyhton=3 包管理看安装的包和版本列表1$ conda list 查找、安装、删除123$ conda search beautifulsoup4$ conda install --name snowflakes beautifulsoup4 #未指定位置安装在当前位置$ conda remove --name snowflakes beautifulsoup4 从Anaconda.org安装包1$ conda install --channel https://conda.anaconda.org/pandas bottleneck 更多命令具体参考：Getting started]]></content>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学使用Github]]></title>
    <url>%2F2017%2F10%2F24%2F%E5%88%9D%E5%AD%A6%E4%BD%BF%E7%94%A8Github%2F</url>
    <content type="text"><![CDATA[Git使用规范流程Git是一个源码管理系统我采取ThoughtBot的Git使用规范流程 第一步：新建分支每次开发新功能，都应该新建一个单独的分支。123456#获取主干最新代码$ git checkout master$ git pull#新建开发分支$ git checkout -b afeature 第二步：提交分支commit分支修改后，提交commit123456#all为保存所有变化(包括新建、修改和删除)$ git add --all#查看发生变动的文件。$ git status#verbose会列出diff的结果$ git commit --verbose diff是Unix系统的一个很重要的工具程序，具体见：读懂diff - 阮一峰的网络日志 第三步：撰写提交信息提交commit时，必须给出完整扼要的提交信息。以下是一个范本：1234Persent-tense summary under 50 characters*More information about commit(under 72 characters)*More information about commit(under 72 characters)http://project.management-system.com/ticket/123 第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、需要注意的问题。最后，提供对应的网址。 第四步：与主干同步12$ git fetch orgin$ git rebase orgin/master 第五步：合并commit分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个(或最多两三个) commit，这样不仅清晰，也容易管理。1$ git rebase -i origin/master 具体参考：Git 使用规范流程 第六步：推送到远程仓库合并commit，推送当前分支到远程仓库。1$ git push --force origin myfeature 第七步：发出Pull Request提交到远程仓库以后，就可以发出Pull Request 到master 分支，然后请求别人进行代码review，确认可以合并到master。 Git常用操作]]></content>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通向外网的梯子]]></title>
    <url>%2F2017%2F10%2F22%2F%E9%80%9A%E5%90%91%E5%A4%96%E7%BD%91%E7%9A%84%E6%A2%AF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[能来到这里想必你已翻出来了，也就没什么说的]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter NoteBook常用快捷键]]></title>
    <url>%2F2017%2F10%2F21%2FJupyter-NoteBook%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Jupyter Notebook 有两种键盘输入模式，命令模式和编辑模式。与Vim类似。 命令模式按Esc进入，编辑模式按Enter进入 命令模式快捷键 快捷键 作用 Shift+Enter 运行本单元，选中下一个单元 Ctrl+Enter 运行本单元 Alt+Enter 运行本单元在下插入新单元 Y 单元转入代码状态 M 单元转入markdown状态 R 单元转入raw状态 Up&amp;K/Down&amp;J 选中上方/下方单元 Shift+K/J 连续选择上方/下方单元 A/B 在上方/下方插入新单元 x/C 剪切/复制选中单元 Shift+V/V 粘贴到上方/下方单元 Z 恢复删除的最后一个单元 DD 删除选中的单元 Shift+M 合并选中的单元 Ctrl+S/S 保存当前文件 L 开关行号 O 转换输出 Shift+O 转换输出滚动 Esc/Q 关闭页面 H 显示快捷帮助 II/00 中断/重启NOteBook内核 Shift+Space/Space 向上/下滚动 编辑模式快捷键 快捷键 作用 Tab 代码补全或者缩进 Shift+Tab 提示 Ctrl+] 向右缩进 Ctrl+[ 向左缩进 Ctrl+Shift+Z/Ctrl+Y 重做 Ctrl+up/down 跳到单元开头/末尾 Ctrl+Left/Right 跳到左边/右边一个字首 Ctrl+BackSpace/Delete 删除前面一个字 Shift+Enter 运行本单元，选中下一个单元 Ctrl+M 切换到命令模式 Ctrl+Enter 运行本单元 Alt+Enter 运行本单元在下插入新单元 Ctrl+/ 注释整行或者取消注释]]></content>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows上好用的软件]]></title>
    <url>%2F2017%2F10%2F14%2FWindows%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[WoxWox：是开源免费强大的快捷启动器辅助工具，快速高效率打开软件,搜索文件打开输入框：alt + space 同类软件也有: Listary , Rolan 包管理工具Chocolatey：如果你认为没有包管理的操作系统是反人类的就用这个吧，Chocolatey 这套包管理系统目前已经包含了近 500 多款常用软件，常用的有Sublime text,git,Google Chrome······ cmdercmder： 不多说，windows命令行神器，支持tab补全，支持了大部分的Linux命令······ 文本编辑器Sublime text3：基于 Python 语言的外挂 API,跨平台（Windows、Linux 和 Mac OS X）,兼容 TextMate 的语言标记语法。关于软件的配置方面见：这里sublime text 3 3143 license 12345678910111213—– BEGIN LICENSE —–TwitterInc200 User LicenseEA7E-8900071D77F72E 390CDD93 4DCBA022 FAF6079061AA12C0 A37081C5 D0316412 4584D13694D7F7D4 95BC8C1C 527DA828 560BB037D1EDDD8C AE7B379F 50C9D69D B35179EF2FE898C4 8E4277A8 555CE714 E1FB0E43D5D52613 C3D12E98 BC49967F 7652EED29D2D2E61 67610860 6D338B72 5CF95C69E36B85CC 84991F19 7575D828 470A92AB—— END LICENSE —— 同类也有： Atom：Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置Git版本控制系统。(维基百科)，插件需要科学上网 VS Code：毕竟宇宙级的 Notepad++：Notepad++，由台湾人侯今吾基于同是开放源代码的Scintilla文本编辑组件并独力研发，整个项目托管于SourceForge.net之上，并两度获得SourceForge社区选择奖——最佳开发工具。（维基百科） IDE没什么说的，大多数网上都能下载，JetBrains家的东西都不错，由于对学生免费，即用教育网邮箱注册，就能获得大学在校的使用时间，分享一个用于接收EDU邮箱的网站：点击这里 待续—– 注：0x13哒的缘故，上面网址有的需要突破GFW的封锁，科学上网详见：这里]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客]]></title>
    <url>%2F2017%2F10%2F13%2Fgithub-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页。 准备 Node.js：点击 Github账号：点击注册 Git：点击 WindowsNode.js在命令行输入:12$ node -v$ npm -v 显示版本信息即可进行下一步 Git配置文档]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
